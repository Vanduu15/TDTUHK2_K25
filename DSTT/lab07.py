# -*- coding: utf-8 -*-
"""Lab07_52100674.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eGCfL1iE58OeM86dbpSK3d9IRx6h4LCh
"""

!pip install simpy

#viducuaco
import numpy as np
u1 = np.array([3,1,1])
u2 = np.array([-1,2,1])
if sum(u1 * u2) == 0:
  print("orthogonal set")
else:
  print("No")

#bai1
import numpy as np
u1=np.array([3,1,1])
u2=np.array([-1,2,1])
u3=np.array([-1/2,2,7/2])
def bai1(u1,u2,u3):
    if sum(u1*u2)==0 and sum(u1*u3)==0 and sum(u2*u3)==0:
        return True
    return False
print("bai1 u1,u2,u3 are orthogonal: ",bai1(u1,u2,u3))

#bai2
#project y=((y*u)/(u*u))*u
print("bai2")
y=np.array([7,6])
u=np.array([4,2])
proj = (sum(y*u)/(sum(u*u)))*u
print(proj)

#bai3
import numpy as np
from math import *

def orthonormal_col(A):
    return (np.round(A.T@A)==np.identity(A.shape[0])).all()
x=np.array([[cos(30),-sin(30)],[sin(30),cos(30)]])
print(orthonormal_col(x))

#bai4
import numpy as np
def orthogonalProjection(y, u):
  if np.sum(u * u) == 0:
    return None
  return np.sum(y * u) / np.sum(u * u) * u
A = np.array([[-10, 13, 7, -11],[2, 1, -5, 3], [-6, 3, 13, -3], [16, -16, -2, 5], [2, 1, -5, -7]])
A = A.T
v = []
v.append(A[0])
for i in range(1, len(A)):
  v.append(A[i])
  for j in range(i):
    v[i] = v[i] - orthogonalProjection(A[i], A[j])
print(np.array(v).T)

#bai5
from sympy import *
A = Matrix(np.array([[1,2,3],[3,2,1],[1,1,1]]))
C, pivot = Matrix.rref(A)
print("bai5")
print(np.array(C))
print(pivot)
print(Matrix.rref(A))

#bai6
#v1.v2.v3.w
#rank(v1,v2,v3)==rank(v1,v2,v3,w)
#np.linalog.matrix_rank(A)=) rank(A) 
import numpy as np
def isLinearCombi(v1, v2, v3,w):
    if len(w)!=len(v1):
        return False
    if np.linalg.matrix_rank(np.array([v1, v2, v3]))<np.linalg.matrix_rank(np.array([v1, v2, v3,w])):
        return False
    return True     
#caua   
v1 = np.array([1, 2, 3, 4])
v2 =np.array([-1, 0, 1, 3])
v3 =np.array([0, 5, -6, 8])
w =np.array([3, -6, 17, 11])

print(isLinearCombi(v1, v2, v3,w))

#caub
v1 = np.array([1, 1, 2, 2])
v2 =np.array([2, 3, 5, 6])
v3 =np.array([2, -1, 3, 6])
w =np.array([0, 5, 3, 0])

print(isLinearCombi(v1, v2, v3,w))
#cauc
v1 = np.array([1, 1, 2, 2])
v2 =np.array([2, 3, 5, 6])
v3 =np.array([2, -1, 3, 6])
w =np.array([-1, 6, 1, -4])
print(isLinearCombi(v1, v2, v3,w))


def isLinearCombi(v1, v2, v3,v4,w):
    if len(w)!=len(v1):
        return False
    if np.linalg.matrix_rank(np.array([v1, v2, v3,v4]))<np.linalg.matrix_rank(np.array([v1, v2, v3,v4,w])):
        return False
    return True 
#caud
v1 = np.array([1, 2, 3, 4])
v2 =np.array([-1, 0, 1, 3])
v3 =np.array([0, 5, -6, 8])
v4 =np.array([1, 15, -12, 8])
v4 =np.array([3, -6, 17, 11])

print(isLinearCombi(v1, v2,v3,v4,w))

#bai7
from sympy import * 
import numpy as np
A=Matrix([[1 ,0, 2, 3],[4,-1, 0, 2],[0,-1 ,-8, -10]])

X=A.nullspace()
v1,v2=X[0],X[1]
v1=list(v1)
v2=list(v2)
print(v1)
print(v2)
X_null=[v1,v2]
print(X_null)

#bai8
from sympy import * 
import numpy as np

def column_space(A,w):
    if len(A)!=len(w):
        return False
    if np.linalg.matrix_rank(np.array(A))<np.linalg.matrix_rank(np.array([A[0],A[1],A[2],A[3],w])):
        return False
    return True 
def is_null_space(A,w):
    if len(A)!=len(w):
        return False
    if np.sum(np.array(A)*np.array(w))==0:
        return True
    return False
def main(A,w):
    if column_space(A,w) and is_null_space(A,w):
        print("The null space and the column space are the same")
    elif column_space(A,w) and not is_null_space(A,w):
        print("The null space is not the same as the column space")
    elif not column_space(A,w) and is_null_space(A,w):
        print("The column space is not the same as the null space")
    else:
        print("The null space and the column space are not the same")

A=[[7, 6, -4, 1],[-5 ,-1 ,0 ,-2],[9, -11, 7, -3],[19 ,-9 ,7 ,1]]
w=[1,1,-1,-3]
main(A,w)

A=[[-8, 5, -2, 0],[-5, 2, 1, -2],[10, -8, 6,-3],[3, -2, 1, 0]]
w=[1,2,1,0]
main(A,w)

#bai9
import numpy as np
import sympy as sp
A=np.array([[5 ,1, 2, 2, 0],[3, 3, 2,-1, -12],[8, 4, 4, -5, 12],[2 ,1 ,1 ,0 ,-2]])
B=np.array([[5,3,8,2],[1,3,4,1],[2,-1,-5,0]])

#cau10
from sympy import * 
import numpy as np

def is_linear_combi(M):
    Z=[0]*M.shape[0]
    if M.shape[0] != M.shape[1]:
        K=np.linalg.solve(M,np.array(Z))
        if len(K[K!=0])==0:
            print("linearly independent")
        else:
            print("linearly dependent")
    else:
        if(np.linalg.det(M)==0):
            print("not linearly independent")
        else:
            print("linearly independent")
            print(np.linalg.solve(M,np.array(Z)))

#caua
M=np.array([[1,0,1],[-2,-4,-1],[0,1,1]])
print(is_linear_combi(M))
#caub
np.array([[1,0,2],[0,1,-2],[2,4,-4]])
print(is_linear_combi(M))

#cauc
M=np.array([[0, 0, 1, 2, 3],[0, 0, 2, 3, 1],[1, 2, 3, 4, 5],[2, 1, 0, 0, 0],[-1, -3, -5, 0, 0]])
print(is_linear_combi(M))

#bai11
import numpy as np
from sympy import *

A=np.array([[1,0,2],[0,1,-2],[2,4,-4]])
print("bai11 ",A.ndim)
c,pivot=Matrix.rref(Matrix(A.T))
print(c[pivot,:])

#bai12
import numpy as np
from sympy import *
def Hilbert_matrix(n):
    M=Matrix(np.zeros((n,n)))
    for i in range(n):
        for j in range(n):
            M[i,j]=1/(i+j+1)
    return M

def Pascal_matrix(n):
    C = [[0 for x in range(2 * n + 1)]
            for y in range(2 * n + 1)]
    for i in range(2 * n + 1):
        for j in range(min(i, 2 * n) + 1):

            if (j == 0 or j == i):
                C[i][j] = 1;

            else:
                C[i][j] = (C[i - 1][j - 1] +
                           C[i - 1][j]);
     
    M=np.zeros((n,n))    
    for i in range(n):
        for j in range(n):
            M[i][j] =C[i+j][j];
    return M

def Magic_matrix(n):
    C = [[0 for x in range(n)]
                   for y in range(n)]

    i = n // 2
    j = n - 1
    num = 1
    while num <= (n * n):
        if i == -1 and j == n:
            j = n - 2
            i = 0
        else:
            if j == n:
                j = 0
            if i < 0:
                i = n - 1
 
        if C[int(i)][int(j)]:
            j = j - 2
            i = i + 1
            continue
        else:
            C[int(i)][int(j)] = num
            num = num + 1
 
        j = j + 1
        i = i - 1
    M=np.zeros((n,n))
    for i in range(0, n):
        for j in range(0, n):
            M[i][j] =C[i][j]
    return M

A=np.array(Hilbert_matrix(5))
B=np.array(Pascal_matrix(5))
C=np.array(Magic_matrix(5))
print(A)
pprint(B)
pprint(C)
D=Matrix(A).nullspace()
E=Matrix(B).nullspace()
F=Matrix(C).nullspace()
def basis(M):
    c,pivot=Matrix.rref(M)
    print(c[pivot,:])

    c,pivot=Matrix.rref(M.T)
    print(c[:,pivot])